### 1267. 统计参与通信的服务器

#### 描述

这里有一幅服务器分布图，服务器的位置标识在 m * n 的整数矩阵网格 grid 中，1 表示单元格上有服务器，0 表示没有。

如果两台服务器位于同一行或者同一列，我们就认为它们之间可以进行通信。

请你统计并返回能够与至少一台其他服务器进行通信的服务器的数量。

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/count-servers-that-communicate

著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 示例

+ 示例 1:
```md
输入：grid = [[1,0],[0,1]]

输出：0

解释：没有一台服务器能与其他服务器进行通信。
```
+ 示例 2:
```md
输入：grid = [[1,0],[1,1]]

输出：3

解释：所有这些服务器都至少可以与一台别的服务器进行通信。
```
+ 示例 2:
```md
输入：grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]

输出：4

解释：第一行的两台服务器互相通信，第三列的两台服务器互相通信，但右下角的服务器无法与其他服务器通信。
```


#### 提示
```md
1. m == grid.length

2. n == grid[i].length

3. 1 <= m <= 250

4. 1 <= n <= 250

5. grid[i][j] == 0 or 1
```

### 解答

+ 解答 1
```js
/**
 * @param {number[][]} grid
 * @return {number}
 */
var countServers = function(grid) {
    let rLen = grid.length, cLen = grid[0].length, count_row = new Array(rLen).fill(0), count_col = new Array(cLen).fill(0), res = 0;
    for(let i = 0; i < rLen; i++) {
        for(let j = 0; j < cLen; j++) {
            if(grid[i][j]) {
                count_row[i]++;
                count_col[j]++;
            }
        }
    }
    for(let i = 0; i < rLen; i++) {
        for(let j = 0; j < cLen; j++) {
            if(grid[i][j] && (count_row[i] > 1 || count_col[j] > 1)) {
                res++;
            }
        }
    }
    return res;
};
```

#### Thoughts

+ 1、做中等难度的题就是要保持好心态，做不出来的时候，只要看答案也能学到新知识，那就轻松愉快地接受吧。这道题，让我想起了我曾经遇到过的一道面试题，计算二维数组里的“块”有几个。不过这俩不是一个题，先略过。

  我的想法就是暴力破解，遍历每一行，遇到1就判断这一行和这一行是否有别的1，有就计数，最后返回结果。

  不用想这样的方法一定超时。题解里有使用dfs的，我不太会用，所以直奔最简单的做法去了。

  两次遍历，第一次遍历，主要就是解决暴力破解的超时问题而进行的。主要是统计每一行和每一列对应的服务器总数。接着第二次遍历的时候，就可以利用第一次遍历得到的总数去进行判断，遇到1时，若对应的行或者列总数任一大于1时，则说明该服务器是连通的，则计数。

  以前也见过类似的技巧，是个不错的巧思。