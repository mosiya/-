### 剑指 Offer 53 - II. 0～n-1中缺失的数字

#### 描述

一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof

著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 示例

+ 示例 1:
```md
输入: [0,1,3]

输出: 2
```
+ 示例 2:
```md
输入: [0,1,2,3,4,5,6,7,9]

输出: 8
```


#### 限制
```md
1 <= 数组长度 <= 10000
```

### 解答

+ 解答 1
```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var missingNumber = function(nums) {
    let len = nums.length;
    let n = len ;
    let sum = (0 + n) * (len + 1) / 2;
    let sum0 = nums.reduce((pre, cur) => pre + cur);
    return sum - sum0
};
```

+ 解答 2
```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var missingNumber = function(nums) {
    for(let i = 0; i < nums.length; i ++) {
        if(nums[i] !== i) {
            return i
        }
    }
    return nums.length
};
```

+ 解答 3
```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var missingNumber = function(nums) {
    let i = 0, j = nums.length - 1;
    while(i <= j) {
        m = (i + j) >> 1
        if(nums[m] == m) {
            i = m + 1
        } else {
            j = m - 1
        }
    }
    return i
};
```

#### Thoughts

+ 1、由于是连续的递增数列，并且缺失值只有一个，我首先想到的就是对等差数列求和然后减去当前数组的所有元素和，得到的差值就是缺失的值。
  
  计算的结果是正确的。不过在这里要注意的是，在等差数列的求和公式 S = (a0 + an) * n / 2 中，对应的an、n分别都是什么。
  
  a0自不必说，就是0。n也不难，应该是0~n-1的个数n，也就是数组长度加1。
  
  而an，我一开始认为是数组最后一个数，结果没通过，因为缺失的数有可能就是最后一个数。于是又改为了最后一个数加1，也不对，这样就不能兼容其他情况了。

  再看了一遍题目，我捋了一下，长度为n-1的数组，元素范围在0~n-1，那么就是说an应该是n-1，也就是数组的长度。于是求和公式就变成了 S = (0 + len) * (len + 1) / 2

  最后得到了正确答案。

+ 2、看了解答以后，看到了一个从头遍历一次，遇到与下标不一致的元素就返回下标的解答，觉得是个更直接的解法，故记录。
  
  需要注意的地方是，当每个元素都与下标一致时，也就是说缺失的是最后一项，它与数组的长度一致，故要返回数组的长度。

+ 3、还有一种解答，是比遍历更快找到的方法，即二分查找。对于有序数组实际上都可以考虑二分查找。
  
  思想是这样的，对于整个数组来说，以缺失数字处划分，左子数组有nums[i] == i，右子数组有nums[i] != i，而缺失数字等于右子数组第一个下标。故可以按照二分查找的方法去做。

  二分查找：左右指针i,j初始化为0和数组的最后一个下标，当i <= j时(范围[i, j]闭区间不为空)，循环执行如下代码：
  
  取左右下标相加/2的下取整为中点指针m
  
  当nums[m] != m时，说明缺失的元素在右子数组内，范围调整为[m + 1, j]，故执行i = m + 1

  否则，说明缺失的元素在左子数组内，范围调整为[i, m - 1]，故执行j = m - 1

  跳出该循环时，i和j分别指向的是右子数组的第一个下标和左子数组的最后一个下标。故最后返回i即可。