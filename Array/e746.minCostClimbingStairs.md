### 746. 使用最小花费爬楼梯

#### 描述

数组的每个索引作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i] (索引从0开始)。

每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。

您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/min-cost-climbing-stairs

著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 示例

+ 示例 1:
```md
输入: cost = [10, 15, 20]

输出: 15

解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。
```
+ 示例 2:
```md
输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]

输出: 6

解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。
```


#### 提示
```md
1. cost 的长度将会在 [2, 1000]。

2. 每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。
```

### 解答

+ 解答 1
```js
/**
 * @param {number[]} cost
 * @return {number}
 */
var minCostClimbingStairs = function(cost) {
    let obj = {};
    function costFn(i) {
        if(i == 0 || i === 1) {
            return cost[i];
        } else {
            if(!obj[i - 1]) {
                obj[i - 1] = costFn(i - 1)
            }
            if(!obj[i - 2]) {
                obj[i - 2] = costFn(i - 2)
            }

            return (cost[i] || 0) + Math.min(obj[i - 1], obj[i - 2]);
        }
    }
    return costFn(cost.length);
};
// 或者
/**
 * @param {number[]} cost
 * @return {number}
 */
var minCostClimbingStairs = function(cost) {
    cost.push(0);
    let len  = cost.length;
    for(let i = 2; i < len; i++) {
        cost[i] = cost[i] + Math.min(cost[i - 1], cost[i - 2]);
    }
    return cost.pop();
};
```

+ 解答 2
```js
/**
 * @param {number[]} cost
 * @return {number}
 */
var minCostClimbingStairs = function(cost) {
    let c1 = 0, c2 = 0, len = cost.length;
    for(let i = 0; i < len; i++) {
        [c1, c2] = [Math.min(c1, c2) + cost[i], c1];
    }
    return Math.min(c1, c2);
};
```


#### Thoughts

+ 1、这道题上来就让人想到了动态规划，但我的动态规划属于完全未开化的部分，这可差点把我给难死了。跟着一些解释和提示懵懵懂懂写了个不伦不类的递归，还超过了时间限制，又迷迷糊糊加了一个缓存，就过了。也是神奇。

  这样的题我这样的做法是绝对不行的，以后再遇到肯定还是不会。但是我刷的本来就是数组啊，我还没打算开始玩动态规划啊，泪目

  后来找了到了一个解释，我一下子又灵光乍现了。其实这道题，不用考虑什么动态规划，就按数组的方案去做，也可以啊。对于楼梯的每一阶来说，要来到这一级，必须是找到前一级和再前一级两者中最小那个(因为只能跨一级或者两级)，再加上当前级需要花费的体力，就是总的花费了。

  这样不就很简单了吗？对于第一级和第二级来说，只要花费当前的体力即可。对于下一级来说，就是看从哪一级跨上来，然后加上自己的体力，存在当前元素里就好了。

  也就是说，把这个数组改造成了每个元素存的都是要到达这一级所花费的体力，那么无论想求哪一级的，都很简单了。所以最后只要返回最后两个元素中比较小的那个就好了。

  我还做了一点点操作，在最后添加一个0，这样数组最后的这个元素就是答案了。

+ 2、把官方的解答也记录下来了，官方使用了两个变量来存储前两级需要花费的体力，思路其实差不多，就是要注意，在遍历数组的时候，c1和c2是如何赋值的，如果不用解构赋值，就必须要有一个临时变量去存一下其中一个变量，等它改变完了再赋给另一个变量。这里很容易错的。

  这道题在我脑子不太清醒的时候真是让我很丧，现在做出来了还是挺好挺开心的。