### 46. 全排列

#### 描述

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/permutations/

著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 示例

+ 示例 1:
```md
输入：nums = [1,2,3]

输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```
+ 示例 2:
```md
输入：nums = [0,1]

输出：[[0,1],[1,0]]
```
+ 示例 3:
```md
输入：nums = [1]

输出：[[1]]
```


#### 提示
```md
1. 1 <= nums.length <= 6

2. -10 <= nums[i] <= 10

3. nums 中的所有整数 互不相同
```

### 解答

+ 解答 1
```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
    if(nums.length < 1) return []
    if(nums.length == 1) return [nums]
    let item = nums[0], _res = permute(nums.slice(1)), len = _res.length, n = _res[0].length, res = [];
    for(let i = 0; i <= n; i++) {
        for(let j = 0; j < len; j++) {
            res.push([..._res[j].slice(0, i), item, ..._res[j].slice(i)]);
        }
    }
    return res;
};
// 或者
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
    if(nums.length < 1) return []
    if(nums.length == 1) return [nums]
    let item = nums[0], _res = permute(nums.slice(1)), res = [];
    for(let i = 0; i <= _res[0].length; i++) {
        for(let j = 0; j < _res.length; j++) {
            let tmp = [..._res[j]];
            tmp.splice(i, 0, item);
            res.push(tmp);
        }
    }
    return res;
};
```

+ 解答 2
```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
    let res = [];
    function backtrack(start) {
        if(start == nums.length) {
            res.push([...nums]);
            return;
        }
        for(let i = start; i < nums.length; i++) {
            [nums[start], nums[i]] = [nums[i], nums[start]];
            backtrack(start + 1);
            [nums[start], nums[i]] = [nums[i], nums[start]];
        }
    }
    backtrack(0);
    return res;
};
```


#### Thoughts

+ 1、这道题我以前是做过的，但大概不是靠自己的想法想出来的，所以这次我要自己想。
  
  这道题一看就知道要用回溯。什么删一个然后递归然后再恢复，我不是太懂。我通过画图大概看了一下，这道题可以从最简单的情况入手，因为题目规定了数组长度最小为1，所以就从1开始讨论。当数组长度为1的时候，全排列的情况只有一种，就是数组本身。当数组长度等于2的时候，相当于在第一种情况下多了一个元素，此时这个元素可以往第一种情况的数组里插空，有两个位置可以插空，形成两个数组，此时，就得到了长度为2的数组的全排列了。当数组长度为3的时候，也是对每一个长度为2的全排列进行三个位置的插空。

  总结一下，当数组长度为n时，设数组长度为n-1的全排列为arr(n-1)，数组长度为n的前排列arr(n)，多的那个元素为item，则要求arr(n)，需要遍历arr(n-1)的每个全排列，将item向每个全排列的可插空位置进行插空，每次插空的结果就是一个全排列，遍历完毕且插空完毕即得到arr(n)。arr(n-1)的一个全排列的长度为n-1，股可插空位置为n-1 + 1，为n

+ 2、试着用官解的回溯法做了一下，需要知道的是如果拆解问题为一个回溯解。这里的解法是，定义一个递归函数backtrack(start, arr)，表示从左往右填到第start个位置，当前排列为arr，那么分为两种情况：
  
  + 如果start == n，说明已经填完了第n个位置，则将arr放入答案数组中，递归结束
  + 如果start < n，则请参考官方解答的详细版本吧：https://leetcode-cn.com/problems/permutations/solution/quan-pai-lie-by-leetcode-solution-2/