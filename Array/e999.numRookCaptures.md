### 999. 可以被一步捕获的棋子数

#### 描述

在一个 8 x 8 的棋盘上，有一个白色的车（Rook），用字符 'R' 表示。棋盘上还可能存在空方块，白色的象（Bishop）以及黑色的卒（pawn），分别用字符 '.'，'B' 和 'p' 表示。不难看出，大写字符表示的是白棋，小写字符表示的是黑棋。

车按国际象棋中的规则移动。东，西，南，北四个基本方向任选其一，然后一直向选定的方向移动，直到满足下列四个条件之一：

+ 棋手选择主动停下来。
+ 棋子因到达棋盘的边缘而停下。
+ 棋子移动到某一方格来捕获位于该方格上敌方（黑色）的卒，停在该方格内。
+ 车不能进入/越过已经放有其他友方棋子（白色的象）的方格，停在友方棋子前。

你现在可以控制车移动一次，请你统计有多少敌方的卒处于你的捕获范围内（即，可以被一步捕获的棋子数）。

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/available-captures-for-rook

著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 示例

+ 示例 1:

```md
输入：[[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","R",".",".",".","p"],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]

输出：3

解释：

在本例中，车能够捕获所有的卒。
```
+ 示例 2:
```md
输入：[[".",".",".",".",".",".",".","."],[".","p","p","p","p","p",".","."],[".","p","p","B","p","p",".","."],[".","p","B","R","B","p",".","."],[".","p","p","B","p","p",".","."],[".","p","p","p","p","p",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]

输出：0

解释：

象阻止了车捕获任何卒。
```
+ 示例 3:
```md
输入：[[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","p",".",".",".","."],["p","p",".","R",".","p","B","."],[".",".",".",".",".",".",".","."],[".",".",".","B",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."]]

输出：3

解释： 

车可以捕获位置 b5，d6 和 f5 的卒。
```

#### 提示
```md
1. board.length == board[i].length == 8

2. board[i][j] 可以是 'R'，'.'，'B' 或 'p'

3. 只有一个格子上存在 board[i][j] == 'R'
```

### 解答

+ 解答 1
```js
/**
 * @param {character[][]} board
 * @return {number}
 */
var numRookCaptures = function(board) {
    let row = 0, column = 0, count = 0;
    for(let i = 0; i < 8; i++) {
        for(let j = 0; j < 8; j++) {
            if(board[i][j] === 'R') {
                row = i;
                column = j;
                break;
            }
        }
    }
    
    for(let j = column - 1; j >= 0; j--) {
        if(board[row][j] === 'B') break;
        if(board[row][j] === 'p') {
            count++;
            break;
        }
    }
    for(let j = column + 1; j < 8; j++) {
        if(board[row][j] === 'B') break;
        if(board[row][j] === 'p') {
            count++;
            break;
        }
    }
    for(let i = row - 1; i >= 0; i--) {
        if(board[i][column] === 'B') break;
        if(board[i][column] === 'p') {
            count++;
            break;
        }
    }
    for(let i = row + 1; i < 8; i++) {
        if(board[i][column] === 'B') break;
        if(board[i][column] === 'p') {
            count++;
            break;
        }
    }
    return count;
};
```

+ 解答 2
```js
/**
 * @param {character[][]} board
 * @return {number}
 */
var numRookCaptures = function(board) {
    let row = 0, column = 0, count = 0,
        Rook = 'R', Bishop = 'B', pawn = 'p',
        directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
    getR: for(let i = 0; i < 8; i++) {
        for(let j = 0; j < 8; j++) {
            if(board[i][j] === Rook) {
                row = i;
                column = j;
                break getR;
            }
        }
    }
    
    for(let direction of directions) {
        let r = row + direction[0], c = column + direction[1];
        while(r >= 0 && r < 8 && c >= 0 && c < 8) {
            if(board[r][c] === Bishop) break;
            if(board[r][c] === pawn) {
                count++;
                break;
            }
            r += direction[0];
            c += direction[1];
        }
    }
    return count;
};
```

#### Thoughts

(节选自解答精选)“这种问题在业界（我也不知道哪来的业界）有一个说法（不要问我咋知道的，问就是水群），就是模拟题，

意即：将题目的意思直接实现出来，没有使用到特定的数据结构和方法。

这些问题常常作为竞赛问题的第一个问题，也叫「签到题」，这种问题就是让你证明：你的小可爱来过了（害羞）”

+ 1、既然是签到题，貌似也没有什么好说的，按照题目老老实实地做就对了。先遍历找到Rook的位置，然后上下左右(东南西北)四个方向遍历一次，找到Bishop就break，找到pawn就将结果加1并break，最后返回结果即可。

+ 2、看了解答，四个几乎一模一样的for循环其实是可以合并的，用一个二维数组保存每个循环要走的方向，然后对每个方向进行循环即可。

  这个二维数组就被称为方向数组。

  看似没什么特别的，但是抽象出来的这个方向数组是很有必要的。比如这道题的变形，将四个方向改成八个方向，那么这种方案只要在方向数组再添加四个方向即可。而第一种方案就要再写四个几乎一样的循环，这样一对比，是不是感觉到了抽象的好处呢？

  在对于棋盘类的题目，方向数组是一种常用有效的抽象和技巧，可以进行记忆。