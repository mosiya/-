### 55. 跳跃游戏

#### 描述

给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/jump-game/

著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 示例

+ 示例 1:
```md
输入：nums = [2,3,1,1,4]

输出：true

解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```
+ 示例 2:
```md
输入：nums = [3,2,1,0,4]

输出：false

解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
```


#### 提示
```md
1. 1 <= nums.length <= 3 * 104

2. 0 <= nums[i] <= 105
```

### 解答

+ 解答 1
```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canJump = function(nums) {
    let max = 0;
    for(let i = 0; i < nums.length - 1; i++) {
        max = Math.max(max, i + nums[i]);
        if(i == max && nums[i] == 0) return false;
    }
    return true;
};
```


#### Thoughts

+ 1、做完了45题跳跃问题II来到这题，竟然很快就做出来了，而且看了一圈解答，我个人觉得我自己的做法和思路最简单巧妙，所以只贴出我自己的代码啦。
  
  具体思路如下：
  
  面对跳跃问题，首先要想到的就是：如果能到达当前元素nums[i]，那么从当前元素出发，能到达的最远距离的下标就是i+nums[i]。这里的下标和元素一定要分得很清楚。
  
  接着要理解的一点就是，什么情况下可能出现无法跳跃到最后一个元素的情况？答案是当数组出现0元素的时候。也就是说，只要数组里的元素都大于0，那一定能跳到最后。
  
  所以，只要在遍历到最后一个元素之前，只要都没有遇到0元素，都是安全的。但一路上我们都是有可能遇到0元素的，那怎么办，怎么一个个判断能不能跨过去呢？
  
  什么样的0元素跨不过去？如果前面的所有元素能到达的最远距离，就是一个0元素，那么这个0元素，就是跨不过去的槛。
  
  所以说，只要维护一个最远距离(其实是个下标)，遍历数组的元素(除了最后一项)，不断更新这个最远距离。当不小心到达了这个最远距离，发现它还是个0元素的时候，那么说明没办法跳到最后一个元素。
  
  如果上面的0坑都被避过去了，那么说明最后一定可以到达最后一个元素。

  以上思路我还发了个题解哈哈。