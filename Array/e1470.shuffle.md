### 1470. 重新排列数组

#### 描述

给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,...,xn,y1,y2,...,yn] 的格式排列。

请你将数组按 [x1,y1,x2,y2,...,xn,yn] 格式重新排列，返回重排后的数组。

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/shuffle-the-array

著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 示例

+ 示例 1:
```md
输入：nums = [2,5,1,3,4,7], n = 3

输出：[2,3,5,4,1,7] 

解释：由于 x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 ，所以答案为 [2,3,5,4,1,7]
```
+ 示例 2:
```md
输入：nums = [1,2,3,4,4,3,2,1], n = 4

输出：[1,4,2,3,3,2,4,1]
```
+ 示例 3:
```md
输入：nums = [1,1,2,2], n = 2

输出：[1,2,1,2]
```


#### 提示
```md
1. 1 <= n <= 500

2. nums.length == 2n

3. 1 <= nums[i] <= 10^3
```

### 解答

+ 解答 1
```js
/**
 * @param {number[]} nums
 * @param {number} n
 * @return {number[]}
 */
var shuffle = function(nums, n) {
    let res = [];
    for(let i = 0; i < n; i++) {
        res[2 * i] = nums[i];
        res[2 * i + 1] = nums[i + n];
    }
    return res;
};
```

+ 解答 2
```js
/**
 * @param {number[]} nums
 * @param {number} n
 * @return {number[]}
 */
var shuffle = function(nums, n) {
    for(let i = 0; i < 2 * n; i++) {
        let j = i;
        j = j < n ? 2 * j : 2 * (j - n) + 1;
        nums[j] += (nums[i] & (2 ** 10 - 1)) << 10;
    }
    for(let i = 0; i < 2 * n; i++) {
        nums[i] = nums[i] >> 10;
    }
    return nums;
};
```

+ 解答 3
```js
/**
 * @param {number[]} nums
 * @param {number} n
 * @return {number[]}
 */
var shuffle = function(nums, n) {
    for(let i = 0; i < 2 * n; i++) {
        if(nums[i] > 0) {
            let j = i;
            while(nums[i] > 0) {
                j = j < n ? 2 * j : 2 * (j - n) + 1;
                [nums[i], nums[j]] = [nums[j], nums[i]];
                nums[j] = -nums[j];
            }
        }
    }
    for(let i = 0; i < 2 * n; i++) {
        nums[i] = -nums[i];
    }
    return nums;
};
```

#### Thoughts

+ 1、这道题其实不难，用一个新的数组按顺序遍历，按题意用下标存入对应的元素即可，返回一个新的数组。难的是如果用空间复杂度为O(1)的方法去解决。

+ 2、我感到很可惜的是我没有自己想就直接看了O(1)空间复杂度的做法(当时的确状态不太好，下次一定要自己想)。主要解决的问题其实是如果将正确的元素存到正确的位置上，还不打搅原来元素的取用？

  答案给了一个很技巧的方案(而且就我做过的这些题，好像这还是一种常用的技巧)，就是考虑二进制的妙用。这道题给的提示里说明了元素的范围不超过1000，如果转化为二进制，只使用了前10个比特位，也就是说，使用32位比特表示的数值还有22位空余是可以利用的。

  于是，可以将每个元素左移10个比特位加到正确位置上的元素去，最后再遍历数组取每个元素右移10个比特位的数值，就是最后的答案。

  这里要注意的有两点，一是如何寻找正确的位置，下标要如何计算。这里使用了小于n作为切割点进行下标的计算。二是，元素左移的时候，有可能高位已经存在了正确的元素的二进制，所以要先抹去高位的比特，再左移相加。方法也不难，与2的10次方减1进行按位与即可。

+ 3、还有一个原地替换的方案，之前也做过类似的，就是使用正负号进行标记，然后不断地替换元素。具体的方案是：

  对于数组的每一个元素，通过下标计算它应在的位置，然后进行交换，交换完毕后，正确位置上的元素要使用负号标记，说明已经移动正确。此时，被交换的位置的元素就是新下标的元素，它也需要用这个新下标去寻找自己正确的位置……于是做了一个循环，终止条件为当前交换以后的位置也被标上了负号，说明该位置也已经正确。

  对整个数组进行遍历，如果小于0，则不需要再进行交换，否则就进入上述的交换循环。

  最后要将做好的数组每个元素都去掉负号，返回这个数组即可。

  太巧妙了。以后遇到这种原地替换的类型题都可以尝试一下了，这又是一类变种的稍微难一些的题。

  原地替换可用的可以是二进制，也可以是标正负号，到时候看题目条件进行调整即可。